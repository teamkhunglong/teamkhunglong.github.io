[ { "title": "CPU broken down", "url": "/posts/CPU-broken-down/", "categories": "general", "tags": "amd, asrock, ryzen", "date": "2022-07-14 11:00:00 +0200", "snippet": "I have this workstation for 3 years now, and this is the first time it hang me up to dry.In case you want to know, this is my configuration: Mobo: Asrock X570 Taichi CPU: Ryzen 9 3900x RAM: Corsair Vengeance RGB Pro 16GB (x4) GPU: MSI RTX 3080Ti Ventux 3X 12GB OC PSU: Leadex Platinum SE 1000W (80+ Platinum)Last Saturday, out of nowhere, the server is not responding. I tried to reboot the machine, but it stuck in the boot loop. Mainboard code 07. The “nice” thing is that in the mainboard manual, there is no code 07As a normal tech savy, I tried these things: CMOS - Clear CMOS. Of course, still 07 Peripherals - Unplug all the cable from SSDs, HDDs, USB devices. Reboot, still 07 GPU - Change the graphic card to my RX570 that I’m sure it works properly. Reboot, still 07 RAM - Remove the RAMs, leave only 1 stick at the time. Reboot, still 07 BIOS - Flashback to older or newer firmware. (Yes, this motherboard can flash BIOS without CPU on). No luck, still 07 CPU - Reseat the CPU, new thermal paste. Reboot, still 07 Going to reddit and cried for help !!!!!So there are at least 3 people like me already, with the same-ish configuration, annually. 2019-11-06 Asrock - X570 Taichi - Troubleshooting - Error Code 07 2020-11-20 x570 Taichi - Dr Debug code 07 - need some help with what to try next! 2021-08-12 X570 Taichi Boot Looping Error Code ‘07’, RMA’d it, new board aaaand ‘07’ still! At this point, I’m sure that the CPU is the one to blame hereI was hoping that the mainboard is dead, so I can replace that bloody south-bridge chipset fan, but it’s just not this case. So, I went online and bought a second-hand 5900x for replacement.I’ve just received the CPU yesterday, and everything works fine now. I was surprised that the CPU died. This is the first time that a CPU failed its job.Fun fact: I bought the 3900x around $500, and now I spent €280 for the 5900x. Surprising how technology changes!" }, { "title": "How to mine with kubernetes", "url": "/posts/how-to-mine-with-kubernetes/", "categories": "operations", "tags": "operations, mining", "date": "2021-09-06 04:00:00 +0200", "snippet": "IntroTL;DR: ghcr-tictactoeỞ post trước, mình có đề cập tới việc chạy miner sử dụng Kubernetes on cloud. Mình đã từng chạy thử và nó hoàn toàn có thể thực hiện được chỉ qua vài dòng code, nhiều khi còn miễn phí.Tại post này, mình sẽ bày cho các bạn cách để tạo một workflow như vậyMinerTrước hết, ta sẽ cần biết cách sử dụng phần mềm đào coin. Có rất nhiều phần mềm dễ sử dụng với mức fee phải chăng như Phoenix Miner hay T-rex Miner. Những phần mềm này thường sẽ switch qua để đào cho author với mức fee là 1% với mỗi đồng mà bạn kiếm được. Do T-rex miner hỗ trợ Linux khá tốt, nên guide này sẽ tích hợp nói về T-rex.Việc sử dụng T-rex đơn giản là đọc commandline options và điền vào các trường tương ứng (link)CICDMục đích cuối cùng của blog này là làm sao để scale khi bạn có nhiều tài nguyên. Khi ấy, mình sẽ nghĩ đến sử dụng Container.Nhìn ở top-down level approach, mình sẽ tạo một Deployment trên Kubernetes, đặt replica với một số lượng nhất định các agent mà mình mong muốn.Nhìn ở bottom-up level approach, mình cần tạo một Docker image và đẩy lên Public container registry (e.g. Dockerhub).Nếu những thuật ngữ trên khó hiểu, thì có thể bạn không phải khán giả cho bài blog này.Do đó, mình sử dụng Github, một nơi lý tưởng để làm việc này. Hơn nữa, nó miễn phí. Dù sao thì mình cũng cần một nơi để CI/CD, tiện có Github workflow, mình sẽ thử sử dụng nó xem sao.Step 1: DockerfileTạo một Docker image trên máy dev để make sure là code chạy được trên môi trường production. Khi dev, có thể test bằng cách enable GPU cho container (ref).Lưu ý: Trên môi trường thực tế, thành phần enable GPU engine cho container không phải là Docker. Do mình sẽ sử dụng lại tool của người khác, nên mình sẽ đụng vào ít thứ nhất có thể.Step 2: Github CI/CDTạo một Github repo, và setup CI/CD pipeline lên đó (ref). Github thậm chí còn cho host free một container registry với dung lượng đến 500MB, quá đủ cho một mining container.Sau khi setup, Github sẽ tự build package cho bạn, và bạn có thể kéo container đó về chạy theo như mô tả trong package.Lưu ý: Bạn có thể dự làm agent và đẩy lên một container registry khác, ví dụ như Gitlab &amp; Dockerhub, thậm chí self-hosted-CR. Ở đây mình sử dụng Github để đơn giản hoá vấn đề.KubernetesKhi có được image trên container registry, bạn sẽ mang nó về deploy lên kubernetes. Có một vài vấn đề quan trọng cần lưu ý: Cài plugin vào node có GPU (ví dụ k8s-device-plugin) Đặt số lượng replica theo nhu cầu sử dụng, một vài cloud provider sử dụng scaleset, nên thậm chí bạn có thể đặt replica vô hạn nếu tài chính dư dả. Chọn nodeSelector để chỉ schedule miner vào những node có GPU. Nên đặt hostAliases cho các domain của miner, nếu không bạn sẽ gặp khó khăn khi giải trình với người quản lý DNS Server &lt;(“)OutroMình có up một chiếc demo public tại github của mình. Bạn hoàn toàn có thể fork ra rồi thay địa chỉ ví của bạn vào và dùng thôi. Dễ như úp mì tôm vậy.Link: minhtt159/ghcr-tictactoe" }, { "title": "Next Malware? Maybe", "url": "/posts/Next-Malware-Maybe/", "categories": "hacks", "tags": "mining, malware", "date": "2021-07-25 12:00:00 +0200", "snippet": "Disclaimer: Mình nên bỏ cái kiểu để title tiếng Anh xong content bằng tiếng Việt như thế nàyPost này cách post trước tầm 3 tháng. Qua 3 tháng vừa rồi, mình đã đào được một số coin nhất định, cũng có một vài kinh nghiệm nhất định trong “nghề crypto”, cũng như một vài skillset nhất định để cuộc sống của mình đơn giản hơn. Nội dung của post này một phần là nối tiếp của post trước, một phần là, hình như mình đã tìm ra một attack target mới, mình nghĩ vậy.Current situationỞ post trước, mình có sử dụng KVM tạo VM để chạy miner. Có một người anh đã bảo mình là anh ấy chạy docker container thì sẽ dễ dàng hơn, không cần phải passthrough làm gì. Điều đó đúng, rất đúng. Việc làm như vậy sẽ đỡ tốn thời gian passthrough hơn và không bị CPU penalty. Dù sao thì việc chạy miner cũng không tốn CPU lắm để mà lo về penalty, nhưng đó cũng là một ý hay.Sau post đó, mình có nói rằng ở use case cụ thể của mình, mình cần phải cài Windows để cài driver unlock cho RTX 3060 thì mới có thể lên được 48MH/s. Hơn nữa, khi cắm GPU vào case Workstation, nó khá nóng, vì vậy, mình đã mua thùng case 4U để dedicate cho việc đào coin này. Nó đã chạy được 3 tháng khá ổn định.What’s new?Docker, GPU, … Kubernetes? Các bạn biết mình đang nói về cái gì rồi chứ? Trong trường hợp không biết, thì mình sẽ giải thích: Kubernetes là một công cụ tự động hóa mạnh, nhiệm vụ của nó là sẽ chạy những docker container đã được định nghĩa sẵn, thực hiện theo kịch bản. Docker Container là một công cụ nhắm tới việc triển khai những dịch vụ microservice một cách dễ dàng, với mức tiêu thụ tài nguyên tối thiểu. GPU nếu không mua được … thì mình đi thuê, chẳng hạn thế.Hiện nay, các Cloud Provider khá là “hào phóng” khi cho mọi người thuê VM có GPU với giá khá rẻ. Bạn có thể thuê một VM có GPU rồi mang nó ra đào coin. Khá nhiều người quen của mình đã làm như vậy, họ thuê Compute VPS để plot Chia chẳng hạn.Vấn đề quan trọng là, làm sao để quản lý nhiều VM GPU. Oke, có thể tạo một VM có nhiều GPU chẳng hạn, nhưng hiện tại, một VM có thể có nhiều nhất 4 GPU. Giả sử, giá ETH tăng lên 10k$ chẳng hạn, và bạn muốn thuê tầm 10 VM GPU, thì làm sao để quản lý nó? Bạn có thể sử dụng ansible để deploy VM một cách nhanh chóng, nhưng giả sử một VM bị lỗi, thì bạn sẽ phải tìm ra VM đó là gì và sửa nó một cách thủ công.Giải pháp của mình hiện tại là mình sẽ sử dụng Kubernetes. Khi sử dụng Kubernetes trên Cloud, bạn có thể tự động tăng số lượng VM instance nếu cần thiết, và giảm số lượng instance với chỉ một nút bấm. Nghe có vẻ là một cách để có thu nhập thụ động đấy nhỉ. Có vẻ đúng là như thế thật.Việc này không mới, thực tế, hồi 2017 (có thể google ra bài blog đó khá dễ), khi ETH tăng mạnh thì đã có những người bắt đầu sử dụng tech stack này để thuê GPU đào coin. Đến năm 2018, ETH crash thì “trò” này không được ai nhắc đến nữa.Ý tưởng là như vậy, rõ ràng là có thể thực hiện được chỉ với một vài dòng code. Vấn đề ở đây là khi nào thì thuê máy? Tính toán chi phí thế nào thì chạy đào coin có lãi. Bởi nếu không lãi, thì đi mua coin rồi HODL luôn cho rồi.Khi IT đi tính ROI?Khi mua máy đào coin, bạn cần tính toán đến việc tản nhiệt cho dàn đào và tiền điện để chạy miner, cũng như bao lâu thì sẽ hòa vốn. Ngược lại, khi thuê máy đào, bạn chỉ cần quan tâm tới việc thuê máy hết bao nhiêu và nó sẽ đào được bao nhiêu tiền. Nếu số tiền đào được cao hơn thì là có lãi, nếu nhỏ hơn thì đi mua coin luôn cho nhanh, hoặc bỏ luôn coin nếu không có đam mê hay niềm tin gì với crypto nữa.Nếu mỗi thế thôi thì đã dễ, mình sẽ chẳng việc gì phải chia sẻ “cần câu cơm” của mình miễn phí cho tất cả mọi người như thế này. Không biết nữa, chắc là mình đã tạo nghiệp nhiều quá nên có thể đây là một cách để mình cảm thấy thanh thản hơn chẳng hạn. For the record, I still want to marry youCơ mà, bài post này lại liên quan đến Malware? WTF?Brain-washOkay, hear me out! Giả sử, bạn không phải trả tiền để thuê máy đào coin thì sao? I mean, not even a dime.Nếu đọc đến phần này rồi thì hãy quên tất cả những gì mình viết ở trên đi. Tính ROI làm gì cho mệt khi mà nguồn tiền đến một cách thụ động theo nghĩa đen.Nếu inference service của một business nào đó bị leak cred chẳng hạn, thì rõ ràng là có thể dùng luôn nó làm miner. Tuyệt vời hơn nữa, nếu có thể thay đổi configuration script của một scale set có GPU thì rõ ràng là chỉ cần đợi tiền về một cách thụ động…KếtDù sao thì EIP-1559 cũng sắp đến, với rate hiện tại thì việc thuê GPU một cách chính thống cũng chẳng thể nào có lãi được. Biết đâu, trong tương lai sẽ có một đồng coin khác áp dụng được cách này thì sao. Việc viết blog thế này có thể khiến mình bị sụt giảm số lượng instance có thể thuê được, nhưng điều đó có phải thú vị hơn sao, mình sẽ càng ngày càng phát triển bản thân để có thêm nhiều skill mới." }, { "title": "Crypto Mining", "url": "/posts/crypto-mining/", "categories": "hacks", "tags": "mining", "date": "2021-04-26 12:00:00 +0200", "snippet": "Mục tiêuVới lượng kiến thức ít ỏi của mình, mình đào coin, bởi vì: Do dịch Covid, mọi người có thời gian rảnh ở nhà trading, không chỉ giá crypto mà giá chứng khoán cũng biến động đáng kể, về cơ bản là tăng. Do dịch Covid, nguồn cung chip bán dẫn (SoC) không đáp ứng đủ nhu cầu của thị trường, nên tất cả mọi linh kiện điện tử đều bị trì trệ theo một cách nào đó; trong đó có card màn hình (GPU), là thành phần chính trong việc đào tiền ảo, cụ thể ở đây là ETH. Vì vậy, thị trường càng khó để đào ETH, cũng dẫn đến việc giá ETH tăng. Do mình cần chạy Homelab, về cơ bản ở nhà mình đã có nhiều PC/workstation/server. Hầu hết những máy này không sử dụng đến chức năng xử lý đồ hoạ, nên mình còn thừa rất nhiều chân cắm GPU. Mình đã có sẵn một vài chiếc GPU ở nhà qua những năm tháng đi học và tích góp mua máy tính. Việc sử dụng tối đa năng suất của những chiếc card này khiến mình cảm thấy đỡ phí số tiền mình đã bỏ ra.Sau tất cả những lý do trên, mình quyết định đào coin để kiếm tiền trả chi phí sinh hoạt hàng tháng (điện - nước - mạng) cũng như kiếm thêm một chút để được ăn cơm có thịt.Mình sẽ không đào coin nếu mình không có kiến thức về Công nghệ Thông tin, hoặc mình phải đầu tư hệ thống từ đầu.Phương phápVới các “dân đào chuyên nghiệp”, họ sẽ xây một máy đào gồm nhiều GPU (khoảng 6-8 chiếc). Vốn đầu tư cho những linh kiện khác ngoài GPU khá thấp, thường là một chiếc mainboard Tàu với nhiều slot PCI-e, cộng thêm các linh kiện khác như CPU / RAM / ổ cứng ở mức tối thiểu, nguồn cũng không phải loại cực tốt. Họ sẽ ưa chuộng loại hệ điều hành giành riêng cho việc đào coin có thể ví dụ như HiveOS. Khi sử dụng cách làm này, máy đào chỉ có nhiệm vụ đào coin và không thể làm việc gì khác. Đây vừa là ưu điểm, vừa là khuyết điểm.Đối với mình, do mình đã có một vài chiếc Workstation từ trước, nên việc mình cắm thêm GPU vào để đào coin sẽ làm tối ưu năng suất của những máy tính hiện có. Với cách làm này, mình có thể tận dụng CPU / RAM còn thừa để làm những ứng dụng khác, xoay quanh những dịch vụ Homelab chẳng hạn.Do các phần mềm đào coin chủ yếu nằm trên hệ điều hành Windows hay hệ điều hành Linux-based, nên mình cần phải có cách nào đó để cung cấp môi trường cho những chiếc card. Tại đây, mình sử dụng phương pháp ảo hoá Windows sử dụng Proxmox và passthrough GPU vào máy ảo. Từ đây, mình bắt đầu đâm đầu vào rabbit hole và không có lối thoát.Mọi chuyện sẽ rất đơn giản nếu mình chỉ cần tạo một vài máy ảo Ubuntu để học lập trình, nhón chân vào DevOps, nhưng khi nói chuyện về việc sử dụng phần cứng, cụ thể ở đây là GPU thì lại là một câu chuyện khác. Phương pháp của mình không sử dụng cài đặt trực tiếp hệ điều hành lên máy tính, nên máy ảo ở chế độ mặc định sẽ không biết nó đang có những phần cứng gì. Để cung cấp phần cứng cho máy ảo, ta cần một tính năng đó là IOMMU (Input–output memory management unit)Ở thế giới server, khi nói về những card màn hình có chức năng ảo hoá (SR-IOV - Single-root input/output virtualization), thì thường nó sẽ có giá trên trời. Bạn có thể tham khảo giá card RTX A6000 và RTX 3090 bởi hai con chip xử lý giống y hệt nhau, cùng số CUDA core. Mình không có tiền để mua những card enterprise, nên mình sẽ dùng những chiếc card consumer như chiếc RTX 3080 mà mình phải giấu ny mua với giá 24.5tr.Khi sử dụng những linh kiện thông thường, để passthrough thì CPU / Mainboard cần phải có trong danh sách hỗ trợ IOMMU. Do mình thường sử dụng các CPU hiệu năng cao, nên tất cả CPU mình sử dụng đều hỗ trợ tính năng này.Tiếp đến việc chọn hệ điều hành, để sử dụng môi trường ảo hoá, có 3 công nghệ lớn nhất hiện nay là QEMU-KVM, Xen và VMware ESxi. Vẫn là câu chuyện do mình nghèo, nên mình sử dụng đồ opensource và free, nên mình lựa chọn QEMU-KVM. Thêm nữa, có nhiều hệ điều hành hỗ trợ QEMU-KVM, nhưng mình thấy hệ điều hành thân thiện người dùng nhất là Proxmox.Sau khi cài đặt Proxmox, mình tiến hành cài VM Windows và Passthrough GPU. Việc chọn Windows hay HiveOS ở bước này thì tuỳ mỗi người, nhưng mình cũng cần dùng Windows ở một vài trường hợp, nên mình chọn Windows. (Down to the rabbit hole: sau khi chạy thì mình nhận ra Windows khá là unstable)Sau khi cài đặt VM Windows, mình sẽ cài đặt các phần mềm cần thiết và tham gia vào mining pool. Do hiệu năng đào của mình thấp, nên mình lựa chọn ethermine, pool này có lựa chọn payout chỉ từ 0.1 ETH, khá phù hợp với năng suất đào của mình.Nếu như thông thường, giả sử máy đào bị not-resonding, bạn cần phải bật/tắt một cách vật lý; thì khi sử dụng Proxmox, bạn có thể bật/tắt máy ảo qua giao diện web như khi sử dụng VMWare hay VirtualBox.Việc cuối cùng phải làm chỉ là ngồi đợi tiền về ví thôi :D HiKếtBài blog đầu tiên này có thể là wall-of-text, nhưng mình sẽ cố gắng edit lại vào đợt rảnh 30/4-1/5 tới. Thanks you all." }, { "title": "Getting started with Kubernetes", "url": "/posts/getting-started-with-Kubernetes/", "categories": "operations", "tags": "operations, kubernetes", "date": "2021-04-01 04:00:00 +0200", "snippet": "TL;DR Blog cực kì xiao lone, bạn nên đọc trên blog kubernetes.io để có được content đầy đủ nhấtTiếp tục câu chuyện về tập đoàn tư bản hàng đầu VN, anh lead mình bắt mình viết một cái guide kiểu Getting Started with Kubernetes, nên mình viết chiếc blog này. Cũng là để giới thiệu với những bạn nào mới muốn nhún chân vào làm về Kubernetes thì có thể hiểu được nó có những cái gì.Dù website gốc có rất nhiều thông tin, mình sẽ chỉ tóm gọn lại rất cơ bản những thứ mình thích nói vào blog ở đây, như một cách giới thiệu về concept của Kubernetes.Đây là bài 1 trong chuỗi series về Kubernetes được dịch và tóm gọn lại từ website gốc.Ý tưởng về KubernetesTại đây, mình sẽ giới thiệu các khái niệm cơ bản để hiểu rõ hơn về hệ thống cũng như các tính năng khái quát của một mạng Kubernetes. Từ đó, bạn có thể hiểu sâu hơn về cách vận hành của nó.Tổng quátPhần này sẽ làm rõ về tổng quan một hệ thống Kubernetes và các thành phần tạo nên nó.Kubernetes là gì?Kubernetes là một nền tàng (platform) mã nguồn mở, dễ dàng sử dụng cũng như mở rộng. Nhiệm vụ của Kubernetes là quản lý các công việc qua container hoặc quản lý các dịch vụ, dễ dàng tự động hoá cũng như cấu hình dịch vụ / công việc. Các dịch vụ, công cụ của Kubernetes được phổ biến và hỗ trợ rộng rãi.Ngày xưa, các dịch vụ được chạy trên những server vật lý. Giả sử, nếu hai dịch vụ cùng chạy trên 1 server vật lý, nếu một dịch vụ dùng hết tài nguyên của hệ thống, dịch vụ kia sẽ không còn tài nguyên để chạy. Để khắc phục vấn đề này, mỗi dịch vụ sẽ phải chạy trên những server vật lý khác nhau. Việc mua thêm server vật lý có thể là một lời giải cồng kềnh, hơn nữa, còn phải nuôi nhiều nhân công để quản lý server vật lý.Khi đó, công nghệ ảo hoá được sinh ra. Thay vì phải sử dụng nhiều server vật lý, ta chỉ cần dùng một server có sức mạnh lớn hơn, và chia tài nguyên cho từng máy ảo (VM). Mỗi máy ảo sẽ có đủ tính năng của một server vật lý bình thường, bao gồm cả một hệ điều hành hoàn chỉnh.Hiện tại, nếu nhiều dịch vụ chỉ được phân chia vào từng VM như thiết kế cũ, nhưng môi trường hoạt động của chúng giống nhau (ví dụ cùng chạy trên Ubuntu 64-bit 18.04 LTS) thì phần tài nguyên để quản lý hệ điều hành sẽ bị lãng phí. Công nghệ Container sinh ra để giải quyết vấn đề này, bao gồm có những tính năng về chia sẻ CPU, RAM, file, … như công nghệ ảo hoá nhưng lại khắc phục được điểm yếu khi phải quản lý cả hệ điều hành.Ngoài ra, công nghệ container còn ưu việt hơn ở một số điểm: Tạo và triển khai ứng dụng theo công nghệ Agile dễ hơn so với VM. Quản lý CI/CD dễ dàng, tự động hơn so với VM. Có nhiều thang đo thông tin hơn so với VM, ví dụ như trạng thái của dịch vụ. Nhất quán về môi trường chạy dịch vụ (it works on my machine) Dễ dàng dựng trên các hệ thống khác nhau: vật lý (on-premise) hay cloud (Amazon, Microsoft, Google) với mọi loại hệ điều hành (Ubuntu, Windows) Các dịch vụ được quản lý phân tán, thay vì tập trung như VM.Dùng Kubernetes khi nào?Container là một cách tối ưu khi phát triển dịch vụ. Giả sử, bạn cần quản lý n-dịch vụ và không được có downtime, nhưng một dịch vụ chết, thì Kubernetes sẽ tự động cung cấp dịch vụ mới, thậm chí có thể không có downtime. Kubernetes có thể mở rộng quy mô của dịch vụ hay tạo thêm những dịch vụ dự phòng một cách dễ dàng.Các tính năng của Kubernetes: Quản lý dịch vụ và cân bằng tải: Kubernetes có thể cung cấp dịch vụ ra mạng ngoài qua DNS name của dịch vụ. Nếu một dịch vụ đang gặp lưu lượng mạng lớn (high traffic), kubernetes có thể cân bằng tải lưu lượng mạng qua những node dịch vụ khác. Điều phối lưu trữ: Có thể dễ dàng tích hợp hệ thống lưu trữ vào mạng Kubernetes, ví dụ như ổ cứng vật lý hay dữ liệu trên cloud. Tự động triển khai và khôi phục (rollout &amp; rollback): Kubernetes có thể tự động triển khai một phiên bản mới của dịch vụ và thu hồi tài nguyên của phiên bản cũ, cũng như khôi phục lại theo yêu cầu. Tự động lựa chọn tài nguyên: Kubernetes có thể nhận yêu cầu về tài nguyên (RAM, CPU) và chia sẻ vào các cụm Node phù hợp để chạy dịch vụ đó. Tự sửa chữa: Nếu một dịch vụ không hoạt động đúng theo kịch bản hoặc chết (fail health check), Kubernetes có thể xoá bỏ container đó và tạo một container mới. Quản lý thông số và mật mã: Kubernetes có thể quản lý các thông tin về mật khẩu, OAuth token, SSH Keys một cách tự động và sẽ chỉ cung cấp thông tin khi được cho phép.Những điểm khác biệt giữa Kubernetes và hệ thống truyền thốngMột hệ thống từ trước đến nay thường là một thể thống nhất. Ví dụ những tính năng như triển khai mã nguồn, mở rộng quy mô, cân bằng tải, ghi nhật kí, giám sát, cảnh báo thường được tích hợp trong một khối; thì Kubernetes sẽ hướng tới việc module hoá các công việc trên. Như kiểu chơi lego vậy.Những thứ cần lưu ý khi dùng Kubernetes: Nếu ứng dụng chạy được bằng Container, thì sẽ chạy được trên Kubernetes. Những công việc xử lý được rất đa dạng, kể cả những công việc stateless / stateful (tham khảo) hay tác vụ xử lý dữ liệu. Không cung cấp những dịch vụ ở cấp ứng dụng ví dụ như hệ thống xử lý dữ liệu (như Spark), hay cơ sở dữ liệu (như MySQL), hệ thống lưu trữ (như Ceph) một cách mặc định. Nhưng những ứng dụng này vẫn có thể được dựng và chạy trên mạng Kubernetes. Không yêu cầu mặc định các phương pháp giám sát hoặc cảnh báo, nhưng có thể tích hợp với các phương pháp chuyên nghiệp hơn để thu thập và trích xuất các thông tin cần thiết. Không bắt buộc phải dùng cấu hình ngôn ngữ/hệ thống, mọi API có thể được định nghĩa tuỳ ý. Không cung cấp bất kì hệ thống cấu hình, bảo trì, quản lý, tự sửa chữa một cách toàn diện nào. Không phải hệ thống điều phối đơn thuần, Kubernetes bao gồm các quy trình điểu khiển độc lập và có thể kết hợp được dễ dàng.Thành phần của KubernetesKhi bạn triển khai một mạng Kubernetes, bạn sẽ có một Cluster. Cluster bao gồm một hoặc nhiều worker, gọi là Node. Mỗi node sẽ chạy một hoặc nhiều ứng dụng được containerized.Mỗi worker node có nhiệm vụ chạy các Pods. Một Pod là một container đang được chạy, một công việc có thể yêu cầu một hoặc nhiều Pod.Lớp quản lý của mạng Kubernetes gọi là Control Plane, mình hay gọi là server node để phân biệt với worker node. Trong khi worker node làm nhiệm vụ chạy các công việc được yêu cầu, thì server node chỉ làm nhiệm vụ quản lý.Trong môi trường production, một hệ thống Kubernetes thường có nhiều server node và worker node, cung cấp sự sẵn sàng cao (high availability - HA). Trong thực tế, mình thường có 2 server node và 3 worker node.Thành phần quản lýThành phần quản lý sẽ đảm nhiệm việc đưa ra các quyết định cho một mạng Cluster, cũng như phát hiện và phản ứng trước một sự kiện nào đó trọng mạng. Ví dụ, ta muốn tạo 2 service front-end và sử dụng cân bằng tải thì sẽ phải đăng kí với control plane. Thành phần quản lý gồm các thành phần con như sau:kube-apiserverCung cấp chính các API trong mạng Kubernetes. Đây là front-end của Cluster. kube-api được thiết kế để mở rộng theo chiều ngang, có nghĩa là bạn có thể chạy nhiều kube-apiserver trên nhiều máy khác nhau và cân bằng lưu lượng mạng giữa các API server đó.etcdLà một nơi lưu trữ thông tin của mạng Kubernetes. Có thể sử dụng để lưu mật khẩu, OAuth token, SSH Keys, docker cred …Do là nơi lưu trữ thông tin nên hoàn toàn có thể sử dụng cơ sử dữ liệu bên ngoài khác ví dụ như MySQL.kube-schedulerNhiệm vụ chính của Scheduler là phân chia các Pod vào các Worker node một cách hợp lý. Ví dụ 1 Worker node có 16GB ram, khi ta chạy 3 Pod, Pod thứ 3 sẽ được phân chia vào một Worker node khác nếu còn tài nguyên.kube-controller-managerNhiệm vụ của Controller là để xử lý các công việc khác nhau: Node Controller: chịu trách nhiệm thông báo &amp; phản hồi nếu một node bị chết. Job Controller: thực hiện và giám sát các Job, tạo một hoặc nhiều Pod tương ứng để thực hiện Job theo yêu cầu. Endpoints Sontroller: kết nối các thành phần dịch vụ và pod (ví dụ như gán IP ngoài tới hệ thống cân bằng tải, sau đó nối đến front-end) Service Account &amp; Token controllers: cung cấp các thông tin được lưu trong etcd đến các Pod nếu có yêu cầu.cloud-controller-managerLà thành phần kết nối Cluster đến các Cloud Provider. Những hệ thống ví dụ như Azure Kubernetes Service (AKS) sẽ có nhiều tính năng liên quan đến thành phần này. Ví dụ để kết nối AKS với ACR (Azure Container Registry) mà không cần đăng nhập qua Docker. Hoặc ví dụ để kết nối đến các load balancer của Cloud.Thành phần trên mỗi worker nodeTrên mỗi worker node sẽ gồm có 2 thành phần, làm nhiệm vụ nhận lệnh từ server node và duy trì các Pod.kube-proxyLà một network-proxy, làm nhiệm vụ duy trì kết nối mạng trong Node, giúp truyền tải các gói tin trong và ngoại NodekubeletLà Agent Pod chạy trên mỗi node, làm nhiệm vụ chạy các container. Kubelet sẽ lấy cấu hình PodSpec được nhận từ server node và dựng lên những Pod với cấu hình đó, đảm bảo việc Pod được chạy ổn định.Container runtimeLà một phần mềm đảm nhiệm môi trường container. Có thể là Docker, containerd, CRI-O, …AddonLà các dịch vụ khác của Kubernetes như DaemonSets, Deployments, … thường nằm trong namespace kube-system. Những tính năng thường có bao gồm: DNS: serve DNS records (chịu, không tìm được từ Tiếng Việt) WebUI: giao diện Web để dễ quản lý (thậm chí từ điện thoại) Resource Monitoring: quản lý tài nguyên, hiển thị các thông số hệ thống, thường được tích hợp trong giao diện Web. Cluster-level Logging: self-explained :shrug:Kubernetes APIAPI, là thành phần core trong Kubernetes, được cung cấp cho người dùng để tương tác với đối tượng (object) trong Kubernetes. Người dùng, những như các Node sẽ tương tác với mạng Kubernetes qua các API này.Có thể kể đến kubectl hay kubeadm là những tool rất tiện lợi để tương tác với Kubernetes Cluster.Đối tượng trong KubernetesKubernetes Object là gìKubernetes Object là một thực thể cụ thể trong hệ thống Kubernetes, những thực thể này mô tả trạng thái của Cluster. Cụ thể hơn: Ứng dụng nào đang được chạy, và được chạy trong Node nào. Tài nguyên có sẵn cho các ứng dụng. Các luật được áp dụng cho ứng dụng. Ví dụ như khả năng tự khởi động lại, tự sửa lỗi, hay tự nâng cấp.Kubernetes Object có 2 trường cần lưu ý là Spec và Status. Spec: trang thái mong muốn của đối tượng. Ví dụ: ứng dụng này sẽ triển khai docker images nginx. Status: trạng thái hiện tại của đối tượng. Ví dụ: ứng dụng này có 1 phiên bản đang được chạy, 2 phiên bản khác đang được triển khai.Tìm hiểu thêm về việc mô tả (describe) một đối tượng ở đâyQuản lý Kubernetes ObjectTrong đa số trường hợp, chúng ta sẽ sử dụng công cụ kubectl để quản lý các đối tượng trong mạng Kubernetes. Có 3 cách để điều khiển một đối tượng: Imperative commands: sử dụng câu lệnh để điều khiển trực tiếp đối tượng. Imperative object configuration: sử dụng file cấu hình để điều khiển đối tượng. Declarative object configuration: sử dụng tập hợp các file cấu hình để điều khiển một hoặc nhiều đối tượng.Name &amp; IDName và ID được sinh ra để phân biệt giữa các đối tượng trong một loại tài nguyên cụ thể. Ví dụ: 2 Pod không thể cùng tên là myapp-123 Pod có thể tên là myapp-123 và Deployment hay Job đồng thời cũng có thể tên là myapp-123Để truy cập vào đối tượng này, có thể sử dụng API tại /api/v1/pods/some-name.NamespaceNamespace được sinh ra với nhiệm vụ làm một môi trường ảo, phân biệt với môi trường thật. Giả sử ta chỉ có 1 Cluster vật lý, nhưng lại có 2 môi trường Dev và Prodcution, thì ta có thể tạo ra 2 namespace để phân biệt 2 môi trường với nhau.Có thể xem những namespace với câu lệnh kubectl get namespaceLưu ý, có những đối tượng nằm trong namespace ví dụ như mạng ảo; nhưng lại có những đối tượng không nằm trong namespace ví dụ như storage.Label &amp; SelectorLabel là một cặp key-value để quản lý đối tượng dễ hơn, cụ thể hơn so với namespace. Thêm nữa, người dùng có thể tự tạo label một cách tuỳ ý. Ví dụ: “release” : “stable”, “release” : “canary” “environment” : “dev”, “environment” : “qa”, “environment” : “production” “tier” : “frontend”, “tier” : “backend”, “tier” : “cache” “partition” : “customerA”, “partition” : “customerB” “track” : “daily”, “track” : “weekly”Có thể sử dụng Selector hay NodeSelector để chỉ định Pod sẽ được chạy trên một node nào đó phù hợp.AnnotaionGiống với Label, nhưng Annotation hướng đến những metadata lớn hơn và tự động so với Label. Ví dụ: Thông tin về timestamps, release IDs, git branch, PR numbers, image hashes, và registry address :shrug: Các endpoint về nhật kí, giám sát hoặc cảnh báo. Các thông tin về phiên bản thư viện 3rd party. Vân vân, …Kết luậnBài blog này đã giới thiệu qua một số thuật ngữ trong Kubernetes cũng như một vài use case khi nào nên sử dụng Kubernetes. Bài blog tiếp theo trong chuỗi series có thể sẽ nói về các ý tưởng về Container hay Workload, những real case scenario khi triển khai một công việc DevOps.#GLHF" }, { "title": "How to DevOps 101", "url": "/posts/how-to-DevOps/", "categories": "operations", "tags": "operations, devops, kubernetes", "date": "2021-03-31 04:00:00 +0200", "snippet": "ref: link 1 link 2Giới thiệuBlog này viết dựa trên bài ref ở trên, bên cạnh đó mình sẽ biến đổi một chút để phù hợp hơn với use case của mình. Dù sao, mình cũng phải làm việc viết doc này do lead mình bắt mình làm :)Bài blog này sẽ giới thiệu qua những gì cần thiết để nhón chân vào thế giới DevOps. Mình sẽ không giới thiệu quá nhiều về công dụng của nó vì việc này có thể trở thành một bài blog mới. Tại đây, mình sẽ lướt qua một vài công nghệ cần có để bắt đầu DevOps.Level 1Ở bước 1, mình sẽ cần 3 phần nhỏ, bào gồm: ngôn ngữ lập trình, quản lý mã nguồn và hệ điều hành. Đây là 3 thứ tối quan trọng nếu bạn làm IT nói chung và DevOps nói riêng.Ngôn ngữ lập trình (Programming Language)Gì thì gì, làm IT không biết code ít thì cũng biết code nhiều. Một người anh của mình bất cứ khi nào có ai hỏi anh ý về một vấn đề nào đó, anh ý đều bảo “Học lập trình đi”. Lương anh ý gấp 3 lần mình, thu nhập của anh ý cũng phải gấp 10, nên chắc là anh ý nói đúng. Mình cũng thấy đúng.Khi bắt đầu học lập trình, mình bắt đầu học code C/C++. Nếu như ngày xưa, mọi người hay học code bằng Pascal; thì bây giờ, ngành IT nói chung đã khá là dễ thở. Bạn có thể học code bằng C++ hay Java, thậm chí là học Python để nhập môn lập trình. Python là một ngôn ngữ rất dễ sử dụng, dễ bắt đầu. Cái gì quan trọng thì phải nói 3 lần. Vì vậy, nếu chưa biết về lập trình, hay muốn nhón chân vào DevOps thì nên học Python.Khi học Python, bạn cũng muốn xem qua về các kĩ thuật tự động (automation). Làm sao dùng Python để tạo một HTTP request, GET/POST các thứ đồ; nâng cao hơn thì học cách sử dụng một thư viện, dùng API.Ngoài ra, cũng nên xem qua những ngôn ngữ lập trình khác như JavaScript (TypeScript) / Ruby để cuộc sống dễ dàng hơn. Thêm nữa, bạn cần phải học C/C++ bởi để cần hiểu rõ bản chất của lập trình hay muốn học những kĩ thuật nâng cao thì không ngôn ngữ nào dễ bằng C.Quản lý mã nguồn (Source Control)Đến năm 2021 rồi, ở tập đoàn tư bản to nhất VN, có những người lương mấy ngàn $, vẫn chia sẻ mã nguồn dưới dạng USB, hoặc nén lại và gửi qua Google Drive ?? :D ?? Không cần biết bạn có bằng thạc sĩ / tiến sĩ nước ngoài hay gì, nếu bạn lập trình, làm ơn hãy biết một chút về việc quản lý mã nguồn.Để quản lý mã nguồn (versioning), cách dễ nhất là dùng Git. Những dự án từ ngày xưa có thể dùng subversion (svn), nhưng hầu hết bây giờ mọi người đều dùng Git hết. Từ những bài tập lớn ở trên trường, đến những dự án tầm cỡ thế giới kiểu Chromium đều dùng Git. Vì vậy, phải biết dùng Git. Để học dùng Git, tại thời điểm này, bạn có thể thử đẩy code lên Github.Nói đến Github, mình cần nói thêm là ngoài Github, còn rất nhiều kho lưu trữ mã nguồn (repository) khác ví dụ như Gitlab, Azure Devops, … Các dịch vụ lưu mã nguồn rất nhiều, đa số đều miễn phí.Quay ngược lại về versioning, sau khi bạn chọn được repo phù hợp với bản thân, nếu bạn mới bắt đầu thì nên có một versioning tool phù hợp. Có rất nhiều tool có giao diện hoặc được tích hợp với hệ thống. Kể ra ví dụ như: TortoiseGit, Source Tree, … Thật ra, mọi người khi bắt đầu học Git, họ thường dùng luôn dòng lệnh (terminal / command line), cũng để hiểu được các cơ chế của Git. Như mình làm chiếc blog này cũng quản lý đa số trên VSCodeMột lưu ý nhỏ nếu bạn muốn học hành chuẩn chỉ về cách quản lý mã nguồn là nên học cách dùng CMake. Thay vì để tất cả code vào 1 file, hay để tất cả file vào 1 folder, thì bạn nên học cách chia các tính năng ra nhiều file / folder, tương tự như code Java vậy. Việc này nhằm mục đích về sau đọc code đỡ bị pain in the assHệ điều hành (Operating System)Dùng hệ điều hành gì thì cũng làm IT được thôi, làm DevOps cũng thế. Mình thì quen dùng macOS, nhưng mà Windows thì cũng quá tuyệt vời. Nhưng để học một cách chuẩn chỉ, nhất là về DevOps, bạn phải biết về Linux.Nhiều bạn năm 1 năm 2, mới học IT, luôn bị choáng ngợp bởi các thư viện cần thiết để bắt đầu lập trình. Ví dụ như là: cùng là code C/C++ nhưng dùng DevC++ hay CodeBlocks ngon hơn (assume là các bạn quen với Windows chẳng hạn); hoặc là tại sao không build được, nó cứ báo lỗi gì ý.Mình không bảo Linux khủng hơn Windows hay macOS, nhưng những khó khăn bạn đang gặp phải thường giải quyết rất dễ trên Linux. Cụ thể là Ubuntu là một Linux Distro khá thân thiện với người dùng, và cộng đồng cũng hỗ trợ thân thiện hơn nếu bạn dùng Ubuntu. Dù sao, hệ điều hành cũng chỉ là một công cụ, bạn thích cái nào thì dùng cái đó thôi. Như mình, mình dùng macOS khá lâu rồi, nên mình hiểu được cách sử dụng hệ điều hành này. Nếu bạn quen Windows, việc đó cũng oke.Nếu bạn muốn nhón chân vào DevOps, bạn nên biết sử dụng Linux và những command cơ bản. Cách hệ điều hành quản lý người dùng / quản lý file. Lại nói về tập đoàn tư bản to nhất VN, vẫn là những người lương ngàn $, không hiểu ý tưởng chown / chmod là gì; scp báo không có quyền mà ngồi cả một buổi chiều không xử lý được; hay là không biết copy folder mà không có giao diện; không biết mount ổ cứng cơ bảnKhi làm quen với Linux, bạn cần biết sử dụng một vài text editor cơ bản như nano / vim. Để học vim hay emacs thì lại là có thể là một bài blog cực dài khác, nhưng về cơ bản, bạn có thể dùng bất kì công cụ gì mà bạn muốn, miễn là nó work.Ngoài ra, để làm Devops, bạn cần biết về cách quản lý network bằng câu lệnh sử dụng những tool cơ bản như netstat hay iptables. Thêm nữa, bạn cần biết về SSH / Public key + Private key, authorized_keys là gì, known_hosts là gì. Nếu bạn đã setup Github ở bước trên, khả năng cao bạn đã biết dùng privatekey để đẩy code lên Repo khá oke rồi, SSH cũng tương tự vậy.Level 2Đến đây, mọi thứ có khi sẽ không còn vui vẻ như lúc đầu. Có thể bạn sẽ bắt đầu debug từ 8h tối hôm trước đến 6h sáng hôm sau mà không biết tại sao nó lại thế. Nhưng điều đó quan trọng, đây là xương sống của mọi thứ sau này.Level này lại gồm 3 phần nhỏ, nhưng thật ra mỗi phần lại có thể là một bài blog riêng biệt.Hệ thống mạng (networking)Không thể nào mà làm DevOps mà không biết về networking. Nếu mà ở trên nói về phần Dev, thì ở đây làm về phần Ops. Nếu OS là bê tông, thì Network là móng nhà. Đã rất nhiều lần mình phải đập hệ thống đi xây lại từ đầu vì mình thay đổi Network architecture. Vậy nên, việc có kiến thức về hệ thống mạng rất quan trọng.Mình học Khoa học Máy tính (Computer Science), không phải chuyên ngành về Network, nên những kiến thức ở đây mình cũng chỉ học tay ngang, khi cần cái gì mình sẽ học. Ở bước này, bạn nên đã có một dịch vụ nào đó đang chạy để định hình được làm sao để expose dịch vụ đó ra mạng Internet. Mình thì hay dùng nginx cho dễ, hoặc python http-server còn dễ hơn.Ý tưởng của phần này là hiểu được flow của các gói tin. Nếu khi lập trình, bạn cần phải hiểu control flow của chương trình; thì ở đây, bạn cần hiểu làm sao để người dùng sử dụng được dịch vụ của bạn.Bắt đầu từ việc dễ nhất như DHCP/NAT là gì, làm sao để expose dịch vụ của bạn ra ngoài NAT. Trong lúc đó, bạn nên hiểu được subnet là gì? gateway là gì? Do hầu hết các dịch vụ cơ bản đều sử dụng giao thức (protocol) cơ bản như TCP / HTTP, bạn cũng nên đọc qua về các giao thức này.Sau khi vui vẻ đủ dùng, bạn cần hiểu được DNS ý tưởng như thế nào cũng như hoạt động ra làm sao. Ví dụ như việc bạn truy cập vào blog này sử dụng domain teamkhunglong.com thay vì một địa chỉ IP nào đó. Với mô hình nhỏ hơn như Kubernetes, thông thường những dịch vụ chạy trên đó cũng được tương tác với nhau hay được quản lý qua domain thay vì IP.Sau đó, chúng ta cần trang bị những kiến thức cụ thể về DevOps ví dụ như Load Balancer hay Proxy Server. Làm sao khi người dùng truy cập vào domain teamkhunglong.com, sau khi phân giải tên miền đến địa chỉ front-end, làm sao để nó được kết nối đến back-end. Những thuật toán load-balencing gồm có những gì. Làm sao để dựng proxy server để những VM / Container đứng sau mạng ảo có thể kết nối được với internet bên ngoài.Thêm nữa, điều khá quan trọng và không thể thiếu được đó là firewall. Làm sao để chặn truy vấn đến các cổng được mở ra mạng Internet, làm sao để forward cổng dịch vụ được yêu cầu từ trong VM / Container ra mạng ngoài và chặn những cổng dịch vụ khác không cần thiết (ví dụ như port 22 SSH).ContainerizationNãy giờ nói về VM / Container nhiều rồi, mình cũng cần phải nói qua xem đây là cái gì.Nếu bạn đang sử dụng Windows mà muốn dùng thử qua Ubuntu, khả năng cao bạn sẽ sử dụng phần mềm ảo hoá (virtual machine) ví dụ như VMWare. VMWare hay những phần mềm ảo hoá khác ví dụ như VirtualBox, Nox, Qemu, … có nhiệm vụ giả lập một môi trường khác, đơn cử trong trường hợp này là Windows ảo hoá Linux. Công nghệ này gọi là Virtualization.Bên cạnh đó, nếu bạn không cần giả lập cả một hệ điều hành, mà bạn vẫn muốn môi trường của mình được sạch sẽ khi deploy dịch vụ, tránh trường hợp “ơ anh ơi nó chạy trên máy em bình thường mà”; thì bạn phải có một công nghệ khác gọi là Containerization.Trong trường hợp bạn cần có cả ảo hoá lẫn container hoặc các dịch vụ quản lý khác; hệ thống Containerized on Virtualized khá ổn và đa số các dịch vụ online đang sử dụng.Nói tóm lại, công nghệ Containerization được định nghĩa là một môi trường độc lập, riêng biệt với hệ điều hành chủ. Ở đây, mình sẽ ưu tiên dùng Docker vì có nhiều hướng dẫn online để getting started with Docker, cũng như mình sử dụng Docker hàng ngày, thậm chí để build chiếc blog này ở local.Dịch vụ đám mây (cloud serivce)Cuộc chơi DevOps hiện nay có 3 dân chơi chính là Amazon (AWS), Microsoft (Azure) và Google (Cloud). Về cơ bản, những công ty này tạo ra các dịch vụ để giúp công ty / doanh nghiệp deploy dịch vụ nhanh hơn, cũng là nguồn thu nhập chính.Những tính năng có thể kể đến ví dụ như Datablob / Datalake, Virtual Machine / Virtual Network, Public IP, SQL Server, đến những dịch vụ khủng như Application Insight, Container Registry, Key Vault / Event Grid hay thậm chí có thể quản lý cả một mạng Kubernetes.Tất cả những dân chơi này đều cung cấp phiên bản dùng thử hay phiên bản miễn phí cho người chơi thử nghiện. Một ngày đẹp trời, bạn mở billing ra thấy vài chục ngàn $ cũng là chuyện bình thường.Mình thì không có nhiều tiền, nên mình thường làm homelab tại nhà và mua các linh kiện tương ứng. Dù sao thì làm homelab on the budget thì cũng oke, nếu không làm được thì mở quán net cũng được. Chứ mỗi tháng đóng họ cho Cloud Service cũng hơi căng thẳng.Level 3Sau khi có xương sống cho một hệ thống DevOps, những thứ sau optional but crucial, your choice :shrug:Đến bước này, tất cả lựa chọn đều là của bạn, nhưng về cơ bản, để làm DevOps chuẩn bài nên có những bước như sauInfrastructure as codeCơ sở hạ tầng nghe to lắm, nhưng thực ra chỉ có 3 phần lớn cơ bản: Dev / Test Staging ProductionÝ tưởng của 3 hệ thống riêng biệt như vậy là để Dev code những tính năng, sau đó chạy qua 1 lượt Unittest. Sau đó, chương trình / dịch vụ được build ra artifacts để đến bước Staging. Ở bước này, đội tester sẽ có hàng để check lại một lượt cuối trước khi ra Production. Bởi quản lý 3 hệ thống về cơ bản giống nhau, ta không nên làm thủ công mà nên tự động chúng. Và lúc đó, Teraform vào việc.CI/CDTrong đầu mình mỗi khi nhìn vào Continuous Intergration / Continuous Delivery thì mình nghĩ ngay đến term “tự diễn biến / tự chuyển hoá”.Về cơ bản, code của Dev khi được push lên Dev branch, nó sẽ được verify bởi nhiều yếu tố khác nhau: Code có build được không? Code có pass unit test không? Code có “đẹp” không? Code có đảm bảo an toàn bảo mật / các tiêu chuẩn ISO không? Code có va chạm với các code cũ không? Code mới được phủ bao nhiêu phần trăm?Những yếu tố trên không đảm bảo đầy đủ, nhưng ý mình là nó sẽ có một vài tiêu chuẩn như vậy. Để được merge vào master / main, code của Dev phải đảm bảo được tất cả những thứ đó. Nhưng mà, để mà commit nào cũng làm thủ công thì hơi căng thẳng, nên ta cần phải có CI/CD.Tool để làm CI/CD thì vô vàn, dễ nhất là dựng 1 VM rồi đăng kí vào Agent pool để mỗi khi có commit nó sẽ tự động kéo về build. Vấn đề là, đến khi có nhiều Dev, việc 1 agent không thể đảm nhiệm được hết công việc; vì vậy, chúng ta cần nhiều Agent và chạy on-demand. Có thể kể đến Travis-CI, Jenkins làm nhiệm vụ này rất tốt. Thậm chí, ta có thể sử dụng Kubernetes để làm CI/CD. Ý tưởng vẫn như cũ.OrchestrationĐể nói về DevOps mà không có Orchestration thì chắc không gọi là DevOps. Làm sao có thể tự động hoá mà không có kịch bản?Ví dụ thế này, mình đang làm một work flow tương tác với database. Mỗi khi nào có data mới được đẩy vào database, mình cần phải gọi một worker để deal với database đó. Câu hỏi đặt ra là làm sao để tối ưu?Hoặc là, mình có 1 chiếc front-end, 1 chiếc back-end, 1 chiếc load-balancer, 1 chiếc database, hoặc sau này mình sẽ cần scale lên nhiều front-end chẳng hạn. Làm sao để có thể tự động hoá được, và làm sao để có redundancy?Khi ấy, thay vì làm thủ công các công việc, ta có để đóng hết vào trong Container và đưa vào một hệ thống quản lý như Kubernetes. Ý tưởng của Kubernetes quản lý các Container theo “kịch bản”. Ngoài ra, Kubernetes có thể tạo được redundancy nhanh chóng, có thể scale dễ dàng. Như ý tưởng bên trên, ta có thể tạo một service làm CI/CD agent và chạy trên hệ thống Kubernetes vì về cơ bản agent bản chất cũng là một Container. Ngoài Deployment Application, ta có thể tạo Job, chạy on-demand.Người chơi hệ Kubernetes có rất nhiều trên thị trường. Hiện tại mình đang tự dựng vài node cluster ở nhà, cũng như sử dụng Azure Kubernetes Service ở công ty. Theo như mình biết, Amazon cũng có dịch vụ này.Thậm chí, ta có thể tạo kịch bản ngay trên giao diện với Azure App Insights cũng như Rancher cho custom Node. Ez devops?MonitoringCuối cùng, cũng không kém phần quan trọng, đó là monitoring. Làm sao để biết được khi nào thì job completed, khi nào thì service hang? Resource dùng đã hết chưa, hay dùng bao nhiêu %? Có cần scale hệ thống lên tiếp không hay bị bottle-neck ở đâu?Khi ấy, ta cần một tool làm nhiệm vụ giám sát hệ thống. Cũng có rất nhiều tool để làm việc này, trong số đó có Prometheus, Splunk, … làm nhiệm vụ này rất tốt, và có giao diện web, thay vì phải dùng kubectl cli.Kết luậnSau khi tổng kết lại, ta có Tech Stack như sau để nhúng một chân vào cuộc chơi DevOps. Trông có vẻ nhiều, nhưng không hẳn là phải master hết tất cả công cụ để có thể làm được. Hi, chúc các bạn may mắn ~~" }, { "title": "What do you need to DevOps?", "url": "/posts/what-do-you-need-to-devops/", "categories": "operations", "tags": "operations, devops", "date": "2021-03-16 15:50:00 +0100", "snippet": "Đây sẽ là một series thập cẩm tiếng anh / tiếng việt chẳng ra gì nhưng mà là nơi để mình lưu lại các trải nghiệm về devops. Những bài trong blog này được tham khảo bởi nhiều nguồn khác nhau; trong đó hầu hết là github &amp; youtube. Mình sẽ cố gắng ref nhiều nhất có thể. Nếu các bạn quan tâm và có câu hỏi gì, bạn có thể inbox cho mình qua các phương tiện liên lạc có thể có.What do you need?Điều đầu tiên khi bạn bấm vào tab này, bạn phải tìm hiểu được mình muốn cái gì.Do thể loại của tab này là DevOps, mình sẽ nói nhiều về các vấn đề về hệ thống mạng. Với những nhu cầu khác nhau, hệ thống mạng của nhà mỗi người cũng khác nhau. Kể cả nhà chung cư có cùng một thiết kế, tùy thuộc vào gia chủ, cách thiết kế mạng của mỗi nhà lại khác nhau.Hệ thống mạng này đã đủ để sử dụng thoả mãn những nhu cầu cơ bản như truy cập internet, chơi game với độ trễ thấp.Mặc dù vậy, giả sử một ngày đẹp trời, bạn muốn điều khiển máy tính ở nhà “một cách an toàn” chẳng hạn. Bạn sẽ làm gì?Remote control home PCVới những tiện ích có sẵn, chắc chắn các bạn sẽ chọn những dịch vụ như TeamViewer, AnyDesk, Chrome Remote Desktop. Những dịch vụ này hoạt động rất tốt công việc của mình. Bên cạnh đó, có một vài điểm yếu chết người như sau: TeamViewer: Phải trả phí nếu không dùng “cá nhân” AnyDesk: Như TeamViewer nhưng lại ít chức năng hơn Chrome Remote Desktop: MIỄN PHÍ nhưng phải dùng qua Chrome, không pass-through được vài tổ hợp phím liên quan đến trình duyệt, ví dụ Ctrl-WDo mình lười, lại còn nghèo, nên mình quyết định mua một chiếc VPS cơ bản nhất với mức giá 5$/tháng. Rõ ràng là việc mua VPS rẻ hơn mua TeamViewer (24.9$), mà mua VPS lại còn làm được nhiều thứ nữa. Ví dụ như sau:Nếu mình kết nối các thiết bị với VPS / VPN, các máy này sẽ nhìn nhau như mạng local. Khi đó, mình có thể sử dụng các dịch vụ free để điều khiển máy tính sử dụng các giao thức như RPD hay VNC.Như vậy, mình có thể cầm laptop / điện thoại / máy tính bảng để kết nối remote về máy nhà mà chỉ mất 5$/tháng.Nếu không muốn mất tiền, bạn có thể sử dụng Chrome Remote Desktop. Ngoài việc nó miễn phí, phần mềm này còn tự thay đổi đường mạng tối ưu thay vì phải đi lên server của Google.Lưu ýNhiều bạn nghĩ rằng có thể tạo VPN Server trên ISP Modem rồi mở port ra ngoài, làm vậy sẽ đỡ tốn 5$. Nếu hợp đồng mạng không cấp IP tĩnh, luôn có những dịch vụ NoIP cấp cho bạn một domain miễn phí rồi tự trỏ lại về IP của nhà bạn.Mình không bảo rằng cách này sai, nhưng việc mở port modem tại nhà tạo nên một attack surface khá lớn. Hơn nữa, chưa chắc ISP đã cho bạn mở port modem. Để mà nói, 5$ mà để đỡ bị hack thì ai mà chẳng thích chứ :3Do mình đã mua domain rồi, nên mình chọn mua VPS rồi dùng Cloudflare trỏ về. Đây hoàn toàn là lựa chọn cá nhân, mình thấy tiện thì mình làm thôi.Homelab 101?Giả sử, bạn muốn lắp mấy cái camera an ninh tại nhà, bạn mua một hộp camera box về và nối với một chiếc camera. Mở một port trên modem rồi kết nối tới app điện thoại để xem trực tiếp.Mấy hôm sau, bạn muốn host một chiếc blog tại nhà, ví dụ như blog này chẳng hạn. Bạn tạo một chiếc VM rồi expose port đó ra mạng internet.Mấy hôm sau nữa, bạn muốn nghịch smarthome một chút, ví dụ như mở cửa gara, bật / tắt bình nóng lạnh, bật / tắt đèn. Bạn lại tạo một chiếc VM rồi expose port ra mạng internet.Bạn có niềm đam mê với phim ảnh, bạn đã lưu được cả một hệ thống vài trăm GB tài liệu học tập trên máy tính PC ở nhà, nhưng bạn lại muốn lên giường xem hoặc là đi ra ngoài vẫn xem được.Nói chung, những dịch vụ / tiện ích là vô vàn, và việc mở port trên modem là một việc khá là risky =)) Chỉ tốn 5$/tháng; mình đã có một mạng ảo khá an toàn để dựng những dịch vụ như vậy, biết đâu lại mở ra cho mình nhiều cơ hội mới.Do đó, mình mới refactor lại hệ thống mạng ở nhà mình như hình dưới.KếtSeries DevOps của blog này thực chất là để mình log lại những lựa chọn của mình cũng như để mình nhớ cách setup các thứ nhỡ sau này có vấn đề gì phải troubleshoot; cũng như để các bạn đang muốn tìm hiểu về homelab / smarthome tham khảo các thứ.Hi, that’s it for today." }, { "title": "How to build v8 (but old version)", "url": "/posts/how-to-build-v8-old-version/", "categories": "development", "tags": "development, v8, javascript", "date": "2020-10-27 12:00:00 +0100", "snippet": "Why?Một ngày đẹp trời nào đó, bạn muốn build bản cũ của v8 engine để làm theo mấy hướng dẫn exploit chẳng hạn. Nhưng khi làm theo hướng dẫn thì lại thấy lỗi như thế này.Error at //gni/v8.gni:193:3: Dependency not allowed. source_set(target_name){ ...Đại khái là không hiểu lắm, nhưng mà nếu pull bản mới nhất về thì vẫn build được :( chs.Những lỗi về compiling như vậy tìm trên Google khá là khó, và không được trả lời rõ ràng. Không chỉ có v8, mà khá nhiều dự án mã nguồn mở cũng như vậy, ví dụ như WebKit/JavascriptCore. Vậy giờ sao?What?Về cơ bản, mỗi project của google đều được cập nhật qua depot_tool/gclient và đều được cập nhật cùng nhau. Nếu muốn build chromium từ source với v8 từ source, version của chromium phải match với version v8.Gclient ngoài việc pull code về qua mỗi bản cập nhật thì còn quản lý submodule. Version của các submodule không giống với build profile thì cũng không build được.SolutionLướt qua internet với từ khóa Building old revisions, mình tìm được bài này. Vậy nên ở đây mình dịch ra tiếng Việt cho dễ đọc.Lấy phiên bản chuẩn của depot_toolsGiả sử trên source v8 bạn đã checkout branch hoặc commit cần build rồi. Bạn cần chuyển gclient về thời điểm đó.# Lấy thời điểm của phiên bản đã checkout:~/v8/src $ COMMIT_DATE=$(git log -n 1 --pretty=format:%ci)# Checkout phiên bản của depot_tools qua thời điểm đó:~/depot_tools $ git checkout $(git rev-list -n 1 --before=\"$COMMIT_DATE\" master)~/depot_tools $ export DEPOT_TOOLS_UPDATE=0Dọn dẹp repo của v8Do gclient hay commit mới có thể thêm một vài file khác, bạn cần clean repo của v8~/v8/src $ git clean -ffdCập nhật lại các gói phụ thuộcKiểm tra lại phiên bản của các submodule trùng khớp trên gclient~/v8/src $ gclient sync -D --force --resetBuildCuối cùng, bạn build lại như bình thường. Vậy là được!" }, { "title": "SVATTT 2020 Online - Merklision", "url": "/posts/SVATTT-online-merklision/", "categories": "capture-the-flag", "tags": "ctf", "date": "2020-10-24 12:00:00 +0200", "snippet": "IntroNhắc đến CTF thì chắc hẳn bạn đọc của chiếc blog này không còn lạ gì nữa. Mình từng đi thi SvATTT 3 năm, từ 2015-2017, hay chơi mảng Crypto. Mình định tính là năm 2018 nghỉ thi CTF để ra trường đấy, cơ mà giờ đến vòng loại năm 2020 rồi mà mình vẫn chưa cầm được bằng đại học :))Dù sao thì, sau cuộc thi, những cậu em ở UET-CTF chưa làm được bài crypto đã hỏi mình làm sao để làm được bài này.Cuộc thi năm nay mình không ra đề cũng như không liên quan đến ban tổ chức. Với kinh nghiệm tham gia cuộc thi SvATTT, mình thường tìm hiểu về người ra đề để có được bức tranh toàn cảnh về cách giải bài. Ví dụ: 2016 - Có 1 bài crypto 300 do anh Tân của đội PiggyBird ra đề, liên quan đến AES padding oracle. Hồi đó mình không giải được. 2017 - Có 2 bài crypto do cothan ra đề, tên là Onion và NotSideChannel. Về cơ bản, chỉ cần nháp 50%, code 50% thì sẽ có flag. 2018 - Có 1 chuỗi bài crypto do mình ra đề, liên quan đến ECC. Về cơ bản, chỉ cần nháp 20%, code 80% thì sẽ có flag.Năm nay, người ra đề là ndh, một người anh cực bá đến từ KMA-HCM, đồng đội của mình trong team Acebear. Trước mình có làm một số bài của anh Hiếu. Nói chung, bài của anh Hiếu cần nháp 80% và code 20% thì mới có được flag. Như bài này là một ví dụ.BriefSource code của bài có thế tìm thấy ở đây Nhận input n từ người dùng, từ đó sinh ra một chuỗi ngẫu nhiên có n phần tử, mỗi phần tử là 1 chữ cái thuộc a-zA-Z Đưa cho người dùng chuỗi ngẫu nhiên đó, yêu cầu người dùng nhập vào 2020 chuỗi khác, không được trùng lặp. Nếu Merkle-Hash từ input của người dùng đưa ra đúng với Merkle-Hash từ đầu bài sinh ra thì được coi là hợp lệ.Merkle HashĐầu tiên cần tìm hiểu merkle tree - merkle hash là gì. Đầu tiên, merkle tree là một cấu trúc dữ liệu đơn giản, cho phép một khối dữ liệu được băm trên toàn bộ khối dữ liệu một cách độc lập và phân tán.Chiếc ảnh ở Wikipedia giải thích khá rõ về cấu trúc này.Hash tree được sử dụng trong Hash-based cryptography, áp dụng khá tốt trong việc bảo toàn dữ liệu, nghĩa là dữ liệu gửi qua mạng nếu thỏa mãn đúng merkle hash thì khả năng cao dữ liệu đó toàn vẹn. Ví dụ có thể nói đến Bitcoin &amp; Ethereum.Vậy thì làm sao có thể tạo ra được 1 collision, mà đề bài lại bắt tạo ra 2020 collision?CollisionSecond Preimage Attacks với Merkle TreeSecond Preimage Attack nghĩa là mình được đưa cho một tập dữ liệu, và mình phải tìm một tập dữ liệu khác thỏa mãn hash như tập dữ liệu ban đầu.Với Merkle Tree, nếu không kiểm tra kĩ đầu vào, rất dễ để tạp được đáp án như mong muốn. Như hình trên, ta có thể phân tích được một tập dữ liệu khác như sau: Giả sử dữ liệu đầu vào có dạng L1, L2, L3, L4. Tầng giữa sẽ lấy H(L1)+H(L2) và H(L3)+H(L4) làm tầng tiếp theo.Vì vậy, ta có thể đưa tập dữ liệu khác là H(L1)+H(L2), H(L3)+H(L4) thì sẽ sinh ra mã băm cuối tương tự như dữ liệu đầu vào mà vẫn thỏa mãn là không trùng lặp. Ví dụ:M(1, 2, 3, 4) = M(H(1,2), H(3,4))Mặc dù vậy, ta mới chỉ có log2(n) collision, với 0 &lt; n &lt; 2020 thì mới có khoảng 10 collisions.False implementationTrong source code của chương trình, nếu độ dài của dữ liệu đầu vào là số lẻ, phần tử cuối cùng của chuỗi dữ liệu sẽ tự động được lặp lạiDo đó, cứ khi nào gặp bộ dữ liệu có độ dài lẻ, ta lại có 1 collision nữa bằng cách lặp phần tử cuối. Ví dụ:M(1, 2, 3, 4, 5) = M(1, 2, 3, 4, 5, 5)Mặc dù vậy, với mỗi tầng, ta có thể lặp phần tử cuối 1 lần. Mà tổng cộng cũng chỉ có 10 tầng.Nhân đệ quy ?Nếu chỉ nghĩ một cách rời rạc hai cách đụng độ trên, ta có thể sinh ra được 20 nghiệm, ít hơn 100 lần so với yêu cầu đề bài. Vậy làm sao để có được hơn 100 lần nghiệm nữa? Hmm … ngoài nhân đệ quy?Chiến thuật như này: Nếu dữ liệu đầu vào có dạng 1, 2, 3, 4, 5, thì ta sẽ có đụng độ với 1, 2, 3, 4, 5, 5 (áp dụng 2) Từ 1, 2, 3, 4, 5, 5, thì ta sẽ có đụng độ với H(1,2), H(3,4), H(5,5) (áp dụng 1) Từ H(1,2), H(3,4), H(5,5), ta lại có đụng độ với H(1,2), H(3,4), H(5,5), H(5, 5) (áp dụng 2) Nếu lật ngược lại tầng trước đó, ta sẽ có đụng độ với 1, 2, 3, 4, 5, 5, 5, 5 (mind blown)Vậy từ 1 dữ liệu có độ dài bằng 5, ta có thể sinh ra 4 collision như trường hợp vừa rồi (chưa tính đến các tầng tiếp theo).Có thể suy ra được, độ dài lớn nhất mà có thể đụng độ với nhau được là lũy thừa của 2 đầu tiên lớn hơn n (với n = 5 thì max_length = 2**3 = 8).Ta cần ưu tiên chọn n sao cho có thể sinh ra được càng nhiều tầng càng tốt.Để làm được như vậy, n = (((2*2-1)*2-1)*2-1)....; n &lt; 2020, và ta có n = 1025, max_length = 2048.Nếu làm như vậy thì có bao nhiêu nghiệm? Mình cũng không biết nữa …SolutionCó hai cách để sinh ra các trường hợp collision; cách khôn và cách ngu. Ở đây mình chọn cách ngu.Mình chân thành xin lỗi công sức của các anh, các thầy đã dạy mình code những năm qua, nhưng mình lười nên brute được bao nhiêu thì brute thôi, giải được bài này đã ăn điểm rồi á ._.Thuật toán của mình như sau: Do kiểu gì cũng lập lại tầng đầu tiên để tìm đụng độ, mình sẽ loop để lặp thêm phần tử cuối cho đến độ dài 2048. Với mỗi nghiệm, mình sẽ tính merkle hash và lưu lại những đụng độ qua các tầng của nghiệm đó (áp dụng 1). Mình lưu lại các nghiệm vào set như của đề bài, loại ra những nghiệm đã bị trùng lặp (lặp nhiều lắm :D). Trả lại kết quả cho server.Code mình có lưu lại tại đây$ python ./merklision.pyMaximum length can collide is 2048There are 2047 collisionsTakes 11 sec to produceOutroTrong thời gian thi (4 tiếng), hình như có 5 đội giải được bài này. Đối với một cuộc thi CTF online, như vậy cũng khá là khoai. Một team gồm 4 người với 4 bài nghĩa là mỗi người phải hoàn thành hoàn hảo 1 bài của mình. Như đứa em nói" }, { "title": "whoami", "url": "/posts/whoami/", "categories": "general", "tags": "", "date": "2020-10-23 10:00:00 +0200", "snippet": "VIEMinh tên là Trần Tuấn Minh; công việc chính là nghiên cứu bảo mật.Mình bắt đầu lập trình từ cấp 3, khoảnh năm 2012. Mình học chuyên Tin Tổng Hợp (thuộc ĐHQGHN) và học ngành Khoa học Máy tính của Đại học Công nghệ (thuộc ĐHQGHN).Công việc chính của mình liên quan tới Mã độc &amp; Khai thác lỗ hổng phần mềm. Thời gian rảnh, mình có chơi CTF. Mình là thành viên của một số đội CTF (nổi tiếng) như UET-N/A, PiggyBird, AceBear, BabyPhD, PwnPHOFun. Mình bắt đầu viết blog với mục đích chia sẻ lời giải của những bài CTF đã từng làm cũng như xàm xí những câu chuyện trong cuộc sống. Qua thời gian, chiếc blog cũ càng ngày càng trở nên phức tạp, nên mình chuyển nhà qua blog mới này.Bạn có thể liên hệ với mình để: Nhờ hướng dẫn các kĩ thuật hoặc lời giải của bài CTF. Gửi JD công việc. Thông báo lỗi có trên blog này. Rủ mình đi ăn nhậu 🍺Mình sẽ cố gắng trả lời những tin nhắn nhận được; dù vậy, nếu bạn spam tin nhắn thì mình sẽ block bạn á!ENGMy name is Tran Tuan Minh; Security Researcher.I was coding in highschool since 2012. I studied Informatics in High School for Gifted Student (VNU) and Computer Science in University of Engineering &amp; Technology (VNU).My works are related with Malware &amp; Software Exploitation. In my free time, I play CTFs. I’m a member in several CTF-teams like UET-N/A (UET-CTF), PiggyBird, AceBear, BabyPhD, PwnPHOFun. I started blogging to share my CTF writeups and IT-related stuffs in general. It becomes more and more complicated so the blog evolves itself into this form.You may want to make contact with me to: Request a tutorial or writeup. Send a job description. Report an error somewhere in this blog. Buy me a beer 🍺I will take time to respond to any emails I may receive; however, I will block you if you spam my inbox." }, { "title": "How to build a blog like this", "url": "/posts/how-to-build-a-blog-like-this/", "categories": "development", "tags": "development, github, jekyll", "date": "2020-10-22 05:00:00 +0200", "snippet": "Làm sao để tạo được một blog như thế này?Động lực làm blogNếu bạn đã follow mình từ trước, có thể bạn đã biết mình có một chiếc blog ở domain minhtt159.wordpress.com. Trong quá trình sử dụng, mình đã gặp một vài vấn đề: Wordpress cứ thỉnh thoảng lại gửi mail sale 20-30-50% nhằm dụ mình bỏ tiền ra, làm rác luồng mail. Wordpress load rất chậm, dù không có post nào thì điểm Google PageSpeed Insights cũng chỉ được tầm 6x điểm. Wordpress free theme khá xấu, lại còn không customize domain được, mà mình lại tốn 300k để mua domain này rồi, không dùng thì phí á! Sau khi học tin học cơ sở 1 và được điểm B, do website xấu, mình luôn muốn làm một chiếc website cá nhân đẹp đẹp một tí.Dù như vậy, việc chuyển đổi qua chiếc blog như này có thể gặp phải nhiều khó khăn: Toàn bộ source code của chiếc blog này sẽ được public tại trang github. Nếu website sử dụng theme hay animation gì đẹp đẹp, sẽ rất dễ được người khác bế đi như web của Juno_okyo. Learning Curve khá lớn. Đối với người ít code web như mình, việc tạo ra một chiếc blog đẹp đẹp có đủ HTML/CSS/JS tốn khá nhiều công sức.Làm blog như thế này cần những gì?DomainĐầu tiên, tất nhiên rồi, bạn phải có một domain.Mình vô tình được quản lý một vài domain hay ho, vậy nên mình biết làm sao để mua một chiếc. Ở đây, mình sử dụng NameCheap vì thế giới hay dùng. Nếu tiếng anh là một trở ngại đối với bạn, ở Việt Nam có một vài dịch vụ cũng làm việc tương tự như GoDaddy, Nhân Hòa, Hostinger, …Với giá 13$/năm đối với domain .com, tính ra chưa đến 1k/ngày, mà mình lại có một chiếc blog riêng xịn sò như này thì tội gì không đầu tư một chút.DNS Provider (Optional)Mình không biết các trang web lớn họ trỏ DNS qua dịch vụ nào, nhưng ở đây, mình dùng Cloudflare vì nó free và có nhiều tiện ích. Ngoài ra, nghe nói một công ty lớn nào đó đang triển khai giải pháp tương tự, bạn có thể xem qua tại Cloudrity.Khi config domain, bạn có thể tạo một CNAME record để trỏ domain của bạn về trang github.Mail Service (Optional)Khi quản lý mail của matesctf.org, mình được tiếp cận với những hệ thống mã nguồn mở rất bá, trong đó có Zoho. Zoho cho phép bạn tạo một Email Hosting miến phí, điểm bất lợi là bạn chỉ có thể tạo số lượng user giới hạn (hình như là 5 users). Do đó, từ bây giờ bạn có thể gửi thư điện tử cho mình qua email minhtt159@teamkhunglong.com.Github PagesDomain của trang GithubDo mình chỉ cần làm website tĩnh (không kết nối database, không cung cấp dịch vụ, …) nên mình sử dụng Github Pages. Thay vì phải mua một chiếc VPS cấu hình cao và quản lý Webserver, mình có thể sử dụng công cụ miễn phí như của Github. Khó khăn mình đã nói ở trên, nhưng sự đánh đổi là hợp lý với trường hợp của mình.Sử dụng Github Pages giúp mình yên tâm được một việc rằng tất cả nội dung trên blog đều là nội dung tĩnh, khỏi phải lo về vấn đề hacker tấn công vào Webserver (nói vậy thôi chứ mấy anh hacker đừng deface em nhé).Blog FrameworkKhi làm việc cùng những người anh, mình đã dần học hỏi được những công cụ tốt / framework tốt. Ví dụ như người anh có chiếc blog Develbranch cũng sử dụng framework tương tự.Tất nhiên, bạn có thể tự code HTML/CSS/JS như việc mình làm hồi học tin học cơ sở 1. Cơ mà, do mình gà, nên có framework thì mình dùng vậy.Ở đây, mình dùng framework Jekyll với theme Odin. Kho theme của Jekyll không xịn sò, không nhiều animation giống các trang lớn như VCS nhưng cũng đủ đẹp để mình được thỏa sức sáng tạo. Hơn nữa, những blog này mình viết hoàn toàn sử dụng markdown nên không phải lo khi đọc trên các phiên bản trình duyệt hay điện thoại khác.Google AnalyticsLàm web gì mà không chạy SEO? Thật ra, mình rất thích tính năng này của Wordpress. Nhờ có nó, mình biết được bài nào có nhiều lượng view hơn bài nào. Giả sử, đến thời gian này trong năm, mọi người hay search google ra những writeups cũ của mình ở những giải Sinh viên với An toàn thông tin những năm trước chẳng hạn.Do không dùng Wordpress nữa, mình phải tự chạy Analytics cho blog. Mình nghĩ rằng không có công cụ nào khác tuyệt vời hơn Google Analytics. Sau khi tạo một chiếc data stream, họ gửi cho mình một đoạn byte để mình add vào header của blog. Việc còn lại là của Google lo thôi!LogoNói chung là chiếc blog này không thể đẹp được nếu không có logo xịn sò :D" }, { "title": "Down to the rabbit hole 101", "url": "/posts/down-to-the-rabbit-hole-101/", "categories": "general", "tags": "", "date": "2020-04-26 12:00:00 +0200", "snippet": "Cũng gần được 1 tháng rồi từ khi mình viết bài blog cuối. Blog không phải sự nghiệp chính của mình, nhưng sau 1 tháng vừa rồi, có quá nhiều kiến thức cần note lại để nhỡ sau này có cần thì còn biết phải tìm ở đâu, vậy nên sẽ có series “Down to the rabbit hole” như thế này.Series này chủ yếu sẽ nói về những khó khăn khi làm một chiếc homelab tại nhà. Homelab chắc sẽ là một điều khá thú vị trong một vài năm tới, khi mà những thiết bị IoT dễ dàng tiếp cận hơn, cũng như những ứng dụng IoT càng trở nên hiện đại hơn. Thêm nữa, không phải hầu hết mọi người đều sử dụng PC cấu hình cao hoặc laptop / workstation.Mục tiêu của mình là có một closed-network, cung cấp những dịch vụ thiết yếu cho bản thân. Có những dịch vụ gì thì cùng tìm hiểu thôi :) [Router &amp; Firewall] [Cluster] [NFS] [ZFS] [Plex vs Netflix] Crypto MiningTroubleshoot:/ [Passthrough] more-later-onDatacenter Overview" } ]
